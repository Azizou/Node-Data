{"name":"Node-data","tagline":" Node-Data is a Node.js framework to expose rest data on level 3 (metadata and auto discovery).  This framework will allow declarative style (annotations) to handle most of backend concerns (data relations, transactions, rest, graphql , security) .","body":"##What is Node-Data\r\n\r\nNode-Data is a Node.js framework to expose rest data on level 3 (metadata and auto discovery).\r\n\r\nThis framework will allow declarative style (annotations) to handle most of backend concerns (data relations, transactions, rest, graphql , security) .Yes its on javascript .\r\n\r\nThe target consumers are nodejs based scale projects looking for rewrite/new.\r\n\r\nWhen you write for scale you might missed important aspect which might give you headache if you add the aspect late in your project. Node-Data will have most of aspects required in modern web scale project which can be enabled anytime using only annotations.\r\n\r\nRest level 3 is an amazing protocol allows the autodiscovery of system and application developers can write infrastructure for their code if backend api is level 3.\r\n\r\n##What backend concerns will be handled\r\n\r\n1. Rest level 3 APIs\r\n\r\n2. Model driven system\r\n \r\n3. Data repositories(Only interface)\r\n \r\n4. Auto rest end point generations from repositories\r\n \r\n5. Relations using annotations (one to one , onetomany , manytoone , manyttomany)\r\n \r\n6. Embedded relations support (replication)\r\n\r\n7. Transaction and services using annotations\r\n\r\n8. DI container\r\n\r\n9. Caching second level\r\n  \r\n10.  Search and count (inbuilt elastic search)(repository and query dsl)\r\n  \r\n11.  Logging and auditing using annotations\r\n  \r\n12. Graphql support\r\n  \r\n13.  Meta-data API\r\n  \r\n14.  Security (inbuilt authentication) ,role based autherization , acl\r\n\r\n15. Everythingh is promise (no callback hell)\r\n\r\n\r\n##Technologies used \r\n\r\nlibrary |  version |  Comment/alternative\r\n------------ | ------------- | -------------\r\nnodejs |  5.7.0 | node\r\nexpress | 4.13.3 | Rest middleware\r\nTypeScript | 1.8.4 | Rest middleware\r\nmonogdb | 2.1.3 | Documetndb , nosql , auto sharding\r\nMongoose | 4.3.5 | ORM for mongoDB\r\nMetadata-reflect | 0.1.3 | For reflection and metadata\r\ngulp | 3.9.0 | Compiling Typscript and Build process\r\npassport | 0.2.2 | Authentication , sso , OAtuh , jwt token\r\nNpm-acl | 0.4.9 | Popular acl library\r\nElastic search | 10.1.3 | Search and aggregation\r\nMongosastic | 4.0.2 | Library for integrating Mongoose with ElasticSearch\r\nredis | unknown | Rest middleware\r\n\r\n##Rest level 3 APIs\r\n\r\nNode-data exposes the entities as level 3 REST APIs in HAL format. \r\nRead more about: \r\n[HAL specification] (http://stateless.co/hal_specification.html) \r\n\r\n[Rest API levels] (http://martinfowler.com/articles/richardsonMaturityModel.html) \r\n \r\nIn short, REST level 3 in addition to HTTP verbs(get, put, post etc.) introduces the concept of discoverability. \r\nWhen we navigate to the base-url(assuming base-url for API is \"http://localhost:8080/data/\") for API, we get all the exposed rest APIs in the system. \r\n```javascript\r\n[ \r\n  { \r\n   \"roles\": \"http://localhost:8080/data/roles\" \r\n  }, \r\n  { \r\n   \"users\": \"http://localhost:8080/data/users\" \r\n  } \r\n] \r\n```\r\n \r\n###Suppose we want to get all the users in the system, we go to: \"http://localhost:8080/data/users\". \r\n```javascript\r\n{ \r\n  \"_links\": { \r\n   \"self\": { \r\n    \"href\": \"http://localhost:8080/data/users\" \r\n   }, \r\n   \"search\": { \r\n    \"href\": \"/search\" \r\n   } \r\n  }, \r\n  \"_embedded\": [ \r\n   { \r\n    \"_id\": \"56d692a24043588c0c713564\", \r\n    \"email\": \"alex.b@xyz.com\", \r\n    \"name\": \"Alex Brown\", \r\n    \"_links\": { \r\n     \"self\": { \r\n      \"href\": \"http://localhost:8080/data/users/56d692a24043588c0c713564\" \r\n     }, \r\n     \"roles\":{ \r\n      \"href\": \"http://localhost:8080/data/users/56d692a24043588c0c713564/roles\" \r\n     } \r\n    } \r\n   }, \r\n   { \r\n    \"_id\": \"56d692be4043588c0c713565\", \r\n    \"email\": \"daniel.j@xyz.com\", \r\n    \"name\": \"Daniel Jones\", \r\n    \"_links\": { \r\n     \"self\": { \r\n      \"href\": \"http://localhost:8080/data/users/56d692be4043588c0c713565\" \r\n     }, \r\n     \"roles\":{ \r\n      \"href\": \"http://localhost:8080/data/users/56d692be4043588c0c713565/roles\" \r\n     } \r\n    } \r\n   } \r\n  ] \r\n} \r\n```\r\n\r\nIf we want to fetch all the roles for any user, we can simply fetch the roles url from inside the \"_links\" object for the given user. We just need to know what the base URL is, and after that we just follow the links to get any entity, its relations and so on. \r\n\r\n##Model driven system  \r\n\r\nA model driven system allow one to build a solid backend by defining model . Convention approach enables developers to define specification on models and those specifications can be execute by framework or implemented by developer it self .  \r\n \r\n![sample image render](/images/Modeldrivensystem.png \"Model driven system\")\r\n\r\n##Data repositories (Only interface)\r\n \r\nData repository exposes the basic CRUD operations for a defined model which can be used anywhere in application whether services or controllers. It also allows rest path definition and  authorization settings using attributes. The framework will automatically create the implementation of the interface which can be overridden by developer if required. \r\n\r\n![sample image render](/images/dataRepositories.png \"Data Repositories\")\r\n \r\n##Auto rest end point generations from repositories \r\n \r\nOnce the repository interface defined the framework will automatically generates the rest point . In otherward as a developer you don't need to create the controllers. \r\n \r\nIf custom logic need to be added or entire repository action (like save) need to overridden then a service can be created for the custom logic and service method invocation can be done by defining in attribute over the respective repository's method like below (here we want to do logging after the save) \r\n \r\n ```javascript\r\n@PostAuthorize(\"@currentUserAutherizationServiceImpl.logSavedEntity(principal, returnObject)\") \r\n<S extends T> S save(S entity); \r\n```\r\n \r\n##Relations using annotations (one to one , onetomany , manytoone , manyttomany)\r\n \r\nRelations between models can be established by adding following declarations. To explain we will be using following entities. \r\n \r\n  ```javascript\r\n@document({ name: 'subjects', strict: Strict.true }) \r\nclass SubjectModel { \r\n    @field() \r\n    name: string; \r\n} \r\n  \r\n@document({ name: 'students', strict: Strict.true }) \r\nclass StudentModel { \r\n    @field() \r\n    name: string; \r\n} \r\n  \r\n@document({ name: 'teachers', strict: Strict.true }) \r\nclass TeacherModel { \r\n    @field() \r\n    name: string; \r\n} \r\n```\r\n\r\n###OneToMany \r\nOne-to-many refers to the relationship between two entities A and B in which an element of A may be linked to many elements of B, but a member of B is linked to only one element of A.  \r\n  \r\nFor instance, think of A as mentor, and B as student. A mentor can have several students, but a student can have only one mentor. Following code snippet establish this relation on Teacher entity. \r\n ```javascript\r\n@document({ name: 'teachers', strict: Strict.true }) \r\nclass TeacherModel { \r\n    @field() \r\n    name: string; \r\n    @onetomany({ rel: 'students', itemType: StudentModel, embedded: false }) \r\n    mentoring: Array<StudentModel>; \r\n} \r\n```\r\n\r\nWe have different keywords while declaring the relation. These keywords are used in all the declaration. They are explained as below: \r\nName \r\nDescription \r\nRel \r\nSet document name to which this property is mapped to  \r\nitemType \r\nSet Entity type to which property is mapped to \r\nembedded \r\nSet to true will embed whole document as property value otherwise only primary key will be set as property value \r\n \r\n###ManyToOne \r\nMany-to-one is vice-versa implementation of one-to-many relation. Itâ€™s just that entity is present on other end.  \r\nWe will use example from OneToMany example and add that relation on Student entity. \r\n ```javascript\r\n@document({ name: 'students', strict: Strict.true }) \r\nclass StudentModel { \r\n    @field() \r\n    name: string; \r\n    @manytoone({ rel: 'students', itemType: TeacherModel, embedded: false }) \r\n    mentor: TeacherModel; \r\n} \r\n```\r\n\r\n###OneToOne \r\nOne-to-one refers to the relationship between two entities A and B in which one element of A may only be linked to one element of B, and vice versa.  \r\nFor instance, think of A as teacher, and B as subject. A teacher has only one subject, and a subject is taught by only one teacher. Following code snippet establish this relation on Teacher entity. \r\n ```javascript\r\n@document({ name: 'teachers', strict: Strict.true }) \r\nclass TeacherModel { \r\n    @field() \r\n    name: string; \r\n    @onetoone({ rel: 'subjects', itemType: SubjectModel, embedded: false }) \r\n    subject: SubjectModel; \r\n}  \r\n```\r\n\r\n###ManyToMany \r\nMany-to-many refers to the relationship between two entities A and B in which A may contain a parent record for which there are many children in B and vice versa.  \r\nFor instance, think of A as Student, and B as Subject. A student can have several subjects, and a subject can be taken by several students. Following code snippet establish this relation on Student entity. \r\n ```javascript\r\n@document({ name: 'students', strict: Strict.true }) \r\nclass StudentModel { \r\n    @field() \r\n    name: string; \r\n    @manytomany({ rel: 'subjects', itemType: SubjectModel, embedded: false }) \r\n    subjects: Array<SubjectModel>; \r\n} \r\n```\r\n \r\n##Embedded relations support (*replication*)\r\nA relation can be saved two ways: \r\n1. Link to the related document \r\n2. Embed the related document \r\nEmbedding document helps to get the object and relational data using single query from database thus reducing the database/server hits. This behaviour is managed by using â€˜embeddedâ€™ keyword. When set to true, it fetches the document and embed whole document into the property. In this case, document is replicated and managed by the system. All the embedded documentâ€™s update/delete will automatically update the parent document. \r\n  \r\n*For embedded, please make sure that there is no circular embedding into the system. Although system checks for any circular embedding of the object and throws error.* \r\n\r\n \r\nTransaction and services using annotations - (Not Yet Implemented) \r\nAt the moment, transaction is not supported. But eventually, we will support basic transactions using @transactional annotation.  \r\nRefer to: [Website] (https://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/) for mongodb transaction. \r\n  \r\n##DI container\r\n \r\nNode-data implements a light-weight annotation driven dependency-injection container. All the services(@service) and repositories(@repository) can be injected in other classes. Construction injection (only for services) and property injection are supported currently. To inject the dependency, use the annotation @inject. @inject takes optional \"type\" parameter. When type cannot be inferred from the usage (interface or other types), we can pass the \"concrete\" type as a parameter to inject. \r\nCurrently, we support concrete types only. If anyone wants to use interfaces, check out [Website] (http://inversify.io/) for more. \r\n\r\n*Usage*\r\n ```javascript\r\n@service({singleton: true}) \r\nclass MyService{ \r\n... \r\n} \r\n```\r\n*Inject dependency in another service(constructor and property)* \r\n ```javascript\r\n@service() \r\nclass MyAnotherService{ \r\n@inject() \r\nprivate myServiceAsProp: MyService; \r\n \r\n// constructor injection \r\nconstructor(@inject() myService: MyService){ \r\n} \r\n} \r\n```\r\n\r\n*Inject dependency in any another class(only property injection as of now)*\r\n ```javascript\r\nclass MyNormalClass { \r\n@inject() \r\nprivate myService: MyService; \r\n@inject() \r\nprivate myAnotherService: MyAnotherService; \r\n}\r\n```\r\n \r\n##Caching second level \r\nNot yet implemented.  \r\n \r\n##Search and count (inbuilt elastic search)(repository and query dsl) \r\n\r\n###Searching \r\nSearching is done on MongoDB by default. \r\nProvision is made to search using elasticsearch by changing the settings in the Config file. \r\nSearch on elasticsearch is currently done only on fields that are indexed in the elasticsearch. \r\nAll the search methods are needed to be exposed on the Repository. \r\nCurrently only the \"And\" search operations are supported. \r\n \r\n###Configuring ElasticSearch: \r\n###Config Class:  \r\nSet \"ApplyElasticSearch\" to true to enable ElasticSearch \r\nSet the path of the ElasticSearch service at \"ElasticSearchConnection\" \r\n \r\n###Model Class:  \r\nFor all the fields where the ElasticSearch indexing is requried, set the property in \"@field\" as \"searchIndex:true\" \r\ne.g. As in the \"name\" and \"age\" properties, the searchIndex is set to true. \r\n ```javascript\r\nclass PersonModel { \r\n    @field({searchIndex : true}) \r\n    name: string; \r\n \r\n    @field() \r\n    lastname: string; \r\n \r\n    @field({searchIndex : true}) \r\n    age: number; \r\n \r\nconstructor(){ \r\n} \r\n} \r\n```\r\n\r\n###Configuring Search:  \r\nAll the search methods are defined at the Repository classes. \r\nCurrently the methods are needed to be defined in a fixed format.  \r\nThe method name should start with \"findBy\".  \r\nIt should then be followed by all the fields that are needed to be searched joined by \"And\" \r\n \r\ne.g. \r\n ```javascript\r\nclass PersonRepository { \r\n    findByName() { \r\n    } \r\n    findByNameAndAge() { \r\n    } \r\n    findByNameAndLastname(){ \r\n    } \r\n} \r\n```\r\n \r\n###How the search happens: \r\n \r\nThe API's are defined in such a way that if ALL of the fields to be searched are indexed, then the data is fetched from ElasticSearch. \r\nIf any one the fields to be searched is NOT indexed in ElasticSearch, the data is fetched from MongoDB. \r\nLet us consider the above mentioned \"PersonModel\" and \"PersonRepository\" \r\nThe methods \"findByName\" and \"findByNameAndAge\", queries using the fields \"name\" and \"age\". Since they are defined as Indexed, the data will be fetched from ElasticSearch. \r\nThe method \"findByNameAndLastname\", queries \"name\" and \"lastname\". Since \"lastname\" is not defined as indexed, the data will be fetched from MongoDB. \r\n\r\n \r\n##Logging and auditing using annotations \r\n\r\nNot Implemented\r\n\r\n##Graphql support \r\n\r\nNot Implemented\r\n \r\n##Meta-data API\r\n\r\nMetadata gives the structure of the object. The structure consists of the properties defined in the entities. \r\n\r\n```javascript\r\nFor e.g. â€˜http://localhost/metadataâ€™ will return all the objects metadata : \r\n{ \r\n  \"_links\": [ \r\n    { \r\n      \"name\": \"subjects\", \r\n      \"metadata\": \"http://localhost/Metadata/subjects\" \r\n    }, \r\n    { \r\n      \"name\": \"students\", \r\n      \"metadata\": \"http://localhost/Metadata/students\" \r\n    }, \r\n    { \r\n      \"name\": \"teachers\", \r\n      \"metadata\": \"http://localhost/Metadata/teachers\" \r\n    } \r\n  ] \r\n} \r\n  \r\nFurther running â€˜http://localhost/Metadata/studentsâ€™ will give: \r\n{ \r\n  \"id\": \"students\", \r\n  \"properties\": [ \r\n    { \r\n      \"name\": \"name\", \r\n      \"type\": \"String\" \r\n    }, \r\n    { \r\n      \"name\": \"subjects\", \r\n      \"type\": [ \r\n        \"http://localhost/Metadata/subjects\" \r\n      ] \r\n    } \r\n  ] \r\n} \r\n```\r\nFor primitive types, name of the type is shown.  If the entity has a relationship with another entity then the link of that object's metadata is shown. \r\n \r\n##Security (inbuilt authentication) ,role based autherization , acl \r\n \r\n###System has two types of inbuilt authentication:  \r\n1. *Session based* \r\n2. *Token based* \r\n \r\n###Session based \r\nIt takes the username and password from a user, validates it against the user document in the mongodb. If user is found it creates a session for it. \r\nTo use this a user needs to edit the config.ts file. \r\n```javascript\r\nexport class Security { \r\n    public static isAutheticationEnabled: boolean = true; \r\n    public static isAuthorizationEnabled: boolean = false; \r\n    public static isAutheticationByUserPasswd: boolean = true; \r\n    public static isAutheticationByToken: boolean = false; \r\n} \r\n```\r\nBoth isAutheticationEnabled  and isAutheticationByUserPasswd should be set to TRUE.  \r\nisAutheticationByUserPasswd  and  isAutheticationByToken are mutually exclusive.   \r\n \r\n###Token Based \r\nIt takes the username and password from a user, validates it against the user document in the mongodb. If user is found it creates a token and a refreshToken for that user, and stores in user document itself. Session is not created in this case.  \r\nThe token expiry time can be set in security-config.ts file. \r\n ```javascript\r\npublic static tokenExpiresInMinutes: number = 2;//2 minutes. \r\n```\r\nThe token is set in the cookies and sent to the browser.Using that token, user is considered valid, and provided access to the system. \r\nOnce the token is expired, user can just hit the /token API with refreshToken as the query param. RefreshToken value can be found in the browser cookies. This API will generate a new token for the user, and replace the old token in the user document in the DB, as well as in the cookies. Using the new token user can access the system again, without having to login again and again. \r\n \r\nTo enable token based authentication just edit the config.ts file in following manner \r\n```javascript\r\nexport class Security { \r\n    public static isAutheticationEnabled: boolean = true; \r\n    public static isAuthorizationEnabled: boolean = false; \r\n    public static isAutheticationByUserPasswd: boolean = false; \r\n    public static isAutheticationByToken: boolean = true; \r\n} \r\n```\r\nCurrently any user who is AUTHENTICATED, has access to the entire DB. This is because, AUTHORIZATION is not implemented. In the absence of authorization, the user has access to every document in the db. \r\n\r\n###FaceBook Authentication(SSO) \r\n\r\nFacebook authentication uses facebook to authenticate a user. If the user is present in the db, it stores the token in the user document and creates a session for the user in the application. In case its a new user, it first creates the user in the DB and then creates a session for the user in the application. \r\nTo enable it the only thing needs to be done is in the config.ts file. \r\n```javascript\r\nexport class Security { \r\n    public static isAutheticationEnabled: boolean = true; \r\n    public static isAuthorizationEnabled: boolean = false; \r\n    public static isAutheticationByUserPasswd: boolean = true; \r\n    public static isAutheticationByToken: boolean = false; \r\n} \r\n```\r\n \r\n##Everything is promise (*no callback hell*)\r\n \r\nNode-data internally uses Q to wrap the function calls and returns a promise. Node's callback style coding always lead to what we call as callback hell sooner or later. Using Promise chains is a much cleaner way. \r\n \r\n ```javascript\r\n return Q.nbind(this.find, this)(params) \r\n        .then(result => doSomething(params1)) \r\n        .then(result => doSomethingElse(params2)) \r\n        ... \r\n        .catch(error => Q.reject(error)) \r\n \r\nInstead of (Callback hell): \r\nthis.find(params, (error, data) => { \r\ndoSomething(params1, (error, data) => { \r\ndoSomethingElse(params2, (error, data) => { \r\n... \r\n}); \r\n}); \r\n}) \r\n```\r\nFor details about Q refer to [website API Reference] (https://github.com/kriskowal/q/wiki/API-Reference) \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}