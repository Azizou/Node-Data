/// <reference path="../typings/node/node.d.ts" />
/// <reference path="../typings/mongoose/mongoose.d.ts" />

import * as mongooseTypings from 'mongoose';

var Mongoose = require("mongoose");
var MongooseSchema = Mongoose.Schema;

import * as Utils from "../decorators/metadata/utils";

export class DynamicSchema {
    constructor(target: Object) {
        
    }

    public generate(target: Object): mongooseTypings.SchemaType  {
        var parsedSchema = this.parse(target);
        return new MongooseSchema(parsedSchema);
    }

    public parse(target: Object) {
        if (!target || !(target instanceof Object)) {
            throw TypeError;
        }
        var schema = {};
        var primaryKeyProp;
        var metaDataMap = Utils.getAllMetaDataForAllDecorator(<any>target);
        for (var prop in metaDataMap) {
            // Skip autogenerated primary column
            //if (prop === primaryKeyProp) {
            //    continue;
            //}
            if (Enumerable.from(metaDataMap[prop]).any(x => x.params && x.params.isAutogenerated)) {
                continue;
            }
            Enumerable.from(metaDataMap[prop]).forEach(x => {
                var paramType = x.propertyType;
                if (x.decoratorType !== Utils.DecoratorType.PROPERTY) {
                    return;
                }
                if (paramType.rel) {
                    var relSchema = { type: String, ref: paramType.rel };
                    schema[prop] = paramType.isArray ? [relSchema] : relSchema;
                    return;
                }
                if (paramType.isArray) {
                    schema[prop] = paramType.itemType ? [paramType.itemType] : [];
                    return;
                }
                schema[prop] = paramType.itemType;
            });
        }
        return schema;
    }

}